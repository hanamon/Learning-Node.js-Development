/*
  * [readFile, readFileSync 에서 받아온 data 를 data.toString() 하는 이유는?]
  * data 가 버퍼이기 때문이다.
  * 
  * [버퍼와 스트림 이해하기]
  * 파일을 읽거나 쓰는 방식에는 두 가지가 있다.
  * 바로 버퍼를 사용하는 방식과 스트림을 이용하는 방식이다.
  * 
  * [버퍼링이란?]
  * 버퍼링은 영상을 재생할 수 있을 때까지 데이터를 모으는 동작이다.
  * 
  * [스트리밍이란?]
  * 방송인의 컴퓨터에서 시청자의 컴퓨터로 영상 데이터를 조금씩 전송하는 동작이다.
  * 스트리밍하는 과정에서 버퍼링을 할 수도 있다.
  * 전송이 너무 느리면 화면을 보내기까지 최소한의 데이터를 모아야하기 때문이다.
  * 
  * [노드의 버퍼]
  * 노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해둔다.
  * 파일 데이터를 그 메모리 공간에 저장한 뒤 사용자가 조작할 수 있도록 한다.
  * 이때 메모리에 저장된 데이터가 바로 버퍼이다.
*/

// 버퍼를 직접 다룰 수 있는 클래스가 있다.
// 바로 Buffer 이다.

const buffer = Buffer.from('저를 버퍼로 바꿔보세요.');
console.log('from():', buffer);
console.log('length:', buffer.length);
console.log('toString():', buffer.toString());

const array = [Buffer.from('띄엄 '), Buffer.from('띄엄 '), Buffer.from('띄어쓰기')];
const buffer2 = Buffer.concat(array);
console.log('concat():', buffer2.toString());

const buffer3 = Buffer.alloc(5);
console.log('alloc():', buffer3);

/*
  * [Buffer 객체의 메서드]
  * from(문자열) : 문자열을 버퍼로 바꿀 수 있다.length 속성은 버퍼의 크기를 알린다.
  * toString(버퍼) : 버퍼를 다시 문자열로 바꿀 수 있다. 이때, base64 나 hex 를 인수로 넣으면 해당 인코딩으로도 변환 가능하다.
  * concat(배열) : 배열 안에 든 버퍼를 하나로 합친다.
  * alloc(바이트) : 빈 버퍼를 생성한다. 바이트를 인수로 넣으면 해당 크기의 버퍼가생성된다.
*/

/*
  * [버퍼 방식의 단점]
  * 만약 용량이 100MB인 파일이 있으면 읽을 때 메모리 100MB의 버퍼를 만들어야한다.
  * 이 작업을 동시에 10개만 해도 1GB에 달하는 메모리가 사용된다.
  * 특히 서버처럼 몇 명이 이용할지 모르는 환경에서 메모리 문제가 발생할 수 있다.
  * 또한, 모든 내용을 버퍼에 다 쓴 후에야 다음 동작으로 넘어가므로 읽기, 압축, 쓰기 등의 조작을 연달아 할 때 매번 전체 용량을 버퍼로 처리해야 다음 단계로 넘어갈 수 있다.
*/

/*
  * [버퍼 방식의 단점 극복]
  * 버퍼의 크기를 작게 만든 후 여러 번으로 나눠 보내는 방식이 등장했다.
  * 예를 들면 버퍼 1MB를 만든 후 100MB 파일을 백 번에 걸쳐 나눠 보내는 것이다.
  * 이로써 메모리 1MB로 100MB 파일 전송을 할 수 있다.
  * 이를 편리하게 만든 것이 스트림이다.
*/