/*
  * [동기 메서드와 비동기 메서드]
  * setTimeout 같은 타이머와 process.nextTick 외에도 노드는 대부분의 메서드를 비동기 방식으로 처러한다.
  * 하지만 몇몇 메서드는 동기 방식으로 사용할 수 있다.
  * 특히 fs 모듈이 그러한 메서드를 많이 가지고 있다.
  * 어떤 메섣가 동기 또는 비동기 방식으로 동작하는지와 언제 어떤 메서드를 사용하는지 알아보자.
*/

const fs = require('fs');

// [파일 하나를 여러번 읽기] - 비동기 - 순서 보장 X
console.log('시작');

fs.readFile('./readme2.txt', (err, data) => {
  if (err) throw err;
  console.log('1번', data.toString());
});
fs.readFile('./readme2.txt', (err, data) => {
  if (err) throw err;
  console.log('2번', data.toString());
});
fs.readFile('./readme2.txt', (err, data) => {
  if (err) throw err;
  console.log('3번', data.toString());
});

console.log('끝');

/*
  * 시작과 끝을 제외하고는 결과의 순서가 매번 달라진다.
  * 비동기 메서드들은 백그라운드에 해당 파일을 읽으라고만 요청하고 다음 작업으로 넘어간다.
  * 따라서 파일 읽기 요청만 세 번을 보내고 console.log('끝');을 찍는다.
  * 나중에 읽기가 완료되면 백그라운드가 다시 메인 스레드에 알린다. (메인 스레드는 그제서야 등록된 콜백함수를 실행한다.)
  * 이 방식(비동기)는 상당히 좋다.
  * 왜냐하면 수백 개의 I/O 요청이 들어와도 메인 스레드는 백그라운드에 요청 처리를 위임한다.
  * 그 후로도 얼마든지 요청을 더 받을 수 있다.
  * 나중에 백그라운드가 각각의 요청 처리가 완료되었다고 알리면 그때 콜백 함수를 처리하면 된다.
  * 백그라운드에는 요청 세 개를 거의 동시에 실행한다.
  * 백그라운드가 어떻게 파일 읽기 작업을 처리할까?
*/

/*
  * [비동기 - 논 블로킹 방식]
  * 호출한 함수가 바로 return 되어 다음 작업으로 넘어간다.
  * 백그라운드 작업 완료 여부와 상관 없이 말이다. (다른 일 수행 가능, 논 블로킹이다.)
  * 나중에 백그라운드가 알람을 줄 때 비로소 처리한다. (이벤트 루프가 스택에 콜백을 넣어줄 때)
  * 
  * [동기 - 블로킹 방식]
  * 호출한 함수가 바로 return 되지 않는다.
  * 백그라운드 작업 완료 여부를 계속 확인하며, 백그라운드 작업이 끝나야 return 된다. (다른 일 못하고 대기, 블로킹 발생)
*/